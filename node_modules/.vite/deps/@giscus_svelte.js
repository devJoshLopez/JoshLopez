import "./chunk-TE5TN4QG.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  children,
  claim_element,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  init,
  insert_hydration_dev,
  noop,
  onMount,
  safe_not_equal,
  set_custom_element_data,
  validate_slots
} from "./chunk-VO33WKWQ.js";
import "./chunk-GZA2YTNP.js";
import "./chunk-TYRVL62N.js";

// node_modules/@giscus/svelte/dist/Giscus.svelte
var file = "node_modules/@giscus/svelte/dist/Giscus.svelte";
function create_if_block(ctx) {
  let giscus_widget;
  const block = {
    c: function create() {
      giscus_widget = element("giscus-widget");
      this.h();
    },
    l: function claim(nodes) {
      giscus_widget = claim_element(nodes, "GISCUS-WIDGET", {
        id: true,
        host: true,
        repo: true,
        repoid: true,
        category: true,
        categoryid: true,
        mapping: true,
        term: true,
        strict: true,
        reactionsenabled: true,
        emitmetadata: true,
        inputposition: true,
        theme: true,
        lang: true,
        loading: true
      });
      children(giscus_widget).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_custom_element_data(
        giscus_widget,
        "id",
        /*id*/
        ctx[0]
      );
      set_custom_element_data(
        giscus_widget,
        "host",
        /*host*/
        ctx[1]
      );
      set_custom_element_data(
        giscus_widget,
        "repo",
        /*repo*/
        ctx[2]
      );
      set_custom_element_data(
        giscus_widget,
        "repoid",
        /*repoId*/
        ctx[3]
      );
      set_custom_element_data(
        giscus_widget,
        "category",
        /*category*/
        ctx[4]
      );
      set_custom_element_data(
        giscus_widget,
        "categoryid",
        /*categoryId*/
        ctx[5]
      );
      set_custom_element_data(
        giscus_widget,
        "mapping",
        /*mapping*/
        ctx[6]
      );
      set_custom_element_data(
        giscus_widget,
        "term",
        /*term*/
        ctx[7]
      );
      set_custom_element_data(
        giscus_widget,
        "strict",
        /*strict*/
        ctx[8]
      );
      set_custom_element_data(
        giscus_widget,
        "reactionsenabled",
        /*reactionsEnabled*/
        ctx[9]
      );
      set_custom_element_data(
        giscus_widget,
        "emitmetadata",
        /*emitMetadata*/
        ctx[10]
      );
      set_custom_element_data(
        giscus_widget,
        "inputposition",
        /*inputPosition*/
        ctx[11]
      );
      set_custom_element_data(
        giscus_widget,
        "theme",
        /*theme*/
        ctx[12]
      );
      set_custom_element_data(
        giscus_widget,
        "lang",
        /*lang*/
        ctx[13]
      );
      set_custom_element_data(
        giscus_widget,
        "loading",
        /*loading*/
        ctx[14]
      );
      add_location(giscus_widget, file, 24, 2, 547);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, giscus_widget, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*id*/
      1) {
        set_custom_element_data(
          giscus_widget,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (dirty & /*host*/
      2) {
        set_custom_element_data(
          giscus_widget,
          "host",
          /*host*/
          ctx2[1]
        );
      }
      if (dirty & /*repo*/
      4) {
        set_custom_element_data(
          giscus_widget,
          "repo",
          /*repo*/
          ctx2[2]
        );
      }
      if (dirty & /*repoId*/
      8) {
        set_custom_element_data(
          giscus_widget,
          "repoid",
          /*repoId*/
          ctx2[3]
        );
      }
      if (dirty & /*category*/
      16) {
        set_custom_element_data(
          giscus_widget,
          "category",
          /*category*/
          ctx2[4]
        );
      }
      if (dirty & /*categoryId*/
      32) {
        set_custom_element_data(
          giscus_widget,
          "categoryid",
          /*categoryId*/
          ctx2[5]
        );
      }
      if (dirty & /*mapping*/
      64) {
        set_custom_element_data(
          giscus_widget,
          "mapping",
          /*mapping*/
          ctx2[6]
        );
      }
      if (dirty & /*term*/
      128) {
        set_custom_element_data(
          giscus_widget,
          "term",
          /*term*/
          ctx2[7]
        );
      }
      if (dirty & /*strict*/
      256) {
        set_custom_element_data(
          giscus_widget,
          "strict",
          /*strict*/
          ctx2[8]
        );
      }
      if (dirty & /*reactionsEnabled*/
      512) {
        set_custom_element_data(
          giscus_widget,
          "reactionsenabled",
          /*reactionsEnabled*/
          ctx2[9]
        );
      }
      if (dirty & /*emitMetadata*/
      1024) {
        set_custom_element_data(
          giscus_widget,
          "emitmetadata",
          /*emitMetadata*/
          ctx2[10]
        );
      }
      if (dirty & /*inputPosition*/
      2048) {
        set_custom_element_data(
          giscus_widget,
          "inputposition",
          /*inputPosition*/
          ctx2[11]
        );
      }
      if (dirty & /*theme*/
      4096) {
        set_custom_element_data(
          giscus_widget,
          "theme",
          /*theme*/
          ctx2[12]
        );
      }
      if (dirty & /*lang*/
      8192) {
        set_custom_element_data(
          giscus_widget,
          "lang",
          /*lang*/
          ctx2[13]
        );
      }
      if (dirty & /*loading*/
      16384) {
        set_custom_element_data(
          giscus_widget,
          "loading",
          /*loading*/
          ctx2[14]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(giscus_widget);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(24:0) {#if mounted}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let if_block = (
    /*mounted*/
    ctx[15] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*mounted*/
        ctx2[15]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Giscus", slots, []);
  let { id } = $$props;
  let { host = "https://giscus.app" } = $$props;
  let { repo } = $$props;
  let { repoId } = $$props;
  let { category } = $$props;
  let { categoryId } = $$props;
  let { mapping = "pathname" } = $$props;
  let { term } = $$props;
  let { strict = "0" } = $$props;
  let { reactionsEnabled = "1" } = $$props;
  let { emitMetadata = "0" } = $$props;
  let { inputPosition = "bottom" } = $$props;
  let { theme = "light" } = $$props;
  let { lang = "en" } = $$props;
  let { loading = "eager" } = $$props;
  let mounted = false;
  onMount(() => {
    $$invalidate(15, mounted = true);
    import("./giscus.js");
  });
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Giscus> was created without expected prop 'id'");
    }
    if (repo === void 0 && !("repo" in $$props || $$self.$$.bound[$$self.$$.props["repo"]])) {
      console.warn("<Giscus> was created without expected prop 'repo'");
    }
    if (repoId === void 0 && !("repoId" in $$props || $$self.$$.bound[$$self.$$.props["repoId"]])) {
      console.warn("<Giscus> was created without expected prop 'repoId'");
    }
    if (category === void 0 && !("category" in $$props || $$self.$$.bound[$$self.$$.props["category"]])) {
      console.warn("<Giscus> was created without expected prop 'category'");
    }
    if (categoryId === void 0 && !("categoryId" in $$props || $$self.$$.bound[$$self.$$.props["categoryId"]])) {
      console.warn("<Giscus> was created without expected prop 'categoryId'");
    }
    if (term === void 0 && !("term" in $$props || $$self.$$.bound[$$self.$$.props["term"]])) {
      console.warn("<Giscus> was created without expected prop 'term'");
    }
  });
  const writable_props = [
    "id",
    "host",
    "repo",
    "repoId",
    "category",
    "categoryId",
    "mapping",
    "term",
    "strict",
    "reactionsEnabled",
    "emitMetadata",
    "inputPosition",
    "theme",
    "lang",
    "loading"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Giscus> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("host" in $$props2)
      $$invalidate(1, host = $$props2.host);
    if ("repo" in $$props2)
      $$invalidate(2, repo = $$props2.repo);
    if ("repoId" in $$props2)
      $$invalidate(3, repoId = $$props2.repoId);
    if ("category" in $$props2)
      $$invalidate(4, category = $$props2.category);
    if ("categoryId" in $$props2)
      $$invalidate(5, categoryId = $$props2.categoryId);
    if ("mapping" in $$props2)
      $$invalidate(6, mapping = $$props2.mapping);
    if ("term" in $$props2)
      $$invalidate(7, term = $$props2.term);
    if ("strict" in $$props2)
      $$invalidate(8, strict = $$props2.strict);
    if ("reactionsEnabled" in $$props2)
      $$invalidate(9, reactionsEnabled = $$props2.reactionsEnabled);
    if ("emitMetadata" in $$props2)
      $$invalidate(10, emitMetadata = $$props2.emitMetadata);
    if ("inputPosition" in $$props2)
      $$invalidate(11, inputPosition = $$props2.inputPosition);
    if ("theme" in $$props2)
      $$invalidate(12, theme = $$props2.theme);
    if ("lang" in $$props2)
      $$invalidate(13, lang = $$props2.lang);
    if ("loading" in $$props2)
      $$invalidate(14, loading = $$props2.loading);
  };
  $$self.$capture_state = () => ({
    onMount,
    id,
    host,
    repo,
    repoId,
    category,
    categoryId,
    mapping,
    term,
    strict,
    reactionsEnabled,
    emitMetadata,
    inputPosition,
    theme,
    lang,
    loading,
    mounted
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("host" in $$props2)
      $$invalidate(1, host = $$props2.host);
    if ("repo" in $$props2)
      $$invalidate(2, repo = $$props2.repo);
    if ("repoId" in $$props2)
      $$invalidate(3, repoId = $$props2.repoId);
    if ("category" in $$props2)
      $$invalidate(4, category = $$props2.category);
    if ("categoryId" in $$props2)
      $$invalidate(5, categoryId = $$props2.categoryId);
    if ("mapping" in $$props2)
      $$invalidate(6, mapping = $$props2.mapping);
    if ("term" in $$props2)
      $$invalidate(7, term = $$props2.term);
    if ("strict" in $$props2)
      $$invalidate(8, strict = $$props2.strict);
    if ("reactionsEnabled" in $$props2)
      $$invalidate(9, reactionsEnabled = $$props2.reactionsEnabled);
    if ("emitMetadata" in $$props2)
      $$invalidate(10, emitMetadata = $$props2.emitMetadata);
    if ("inputPosition" in $$props2)
      $$invalidate(11, inputPosition = $$props2.inputPosition);
    if ("theme" in $$props2)
      $$invalidate(12, theme = $$props2.theme);
    if ("lang" in $$props2)
      $$invalidate(13, lang = $$props2.lang);
    if ("loading" in $$props2)
      $$invalidate(14, loading = $$props2.loading);
    if ("mounted" in $$props2)
      $$invalidate(15, mounted = $$props2.mounted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    id,
    host,
    repo,
    repoId,
    category,
    categoryId,
    mapping,
    term,
    strict,
    reactionsEnabled,
    emitMetadata,
    inputPosition,
    theme,
    lang,
    loading,
    mounted
  ];
}
var Giscus = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      id: 0,
      host: 1,
      repo: 2,
      repoId: 3,
      category: 4,
      categoryId: 5,
      mapping: 6,
      term: 7,
      strict: 8,
      reactionsEnabled: 9,
      emitMetadata: 10,
      inputPosition: 11,
      theme: 12,
      lang: 13,
      loading: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Giscus",
      options,
      id: create_fragment.name
    });
  }
  get id() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get host() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set host(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get repo() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set repo(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get repoId() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set repoId(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get category() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set category(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get categoryId() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set categoryId(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mapping() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mapping(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get term() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set term(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strict() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strict(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reactionsEnabled() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reactionsEnabled(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get emitMetadata() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set emitMetadata(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputPosition() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputPosition(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lang() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lang(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<Giscus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<Giscus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Giscus_default = Giscus;
export {
  Giscus_default as default
};
//# sourceMappingURL=@giscus_svelte.js.map
